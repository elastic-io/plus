package utils

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"plus/internal/log"
	"plus/internal/types"
	"regexp"
	"strings"
)

// éªŒè¯ä»“åº“åç§°
func IsValidRepoName(name string) bool {
	// å…è®¸å­—æ¯ã€æ•°å­—ã€è¿å­—ç¬¦ã€ä¸‹åˆ’çº¿ã€ç‚¹å·å’Œæ–œæ 
	// æ·»åŠ äº†ç‚¹å· \.
	matched, _ := regexp.MatchString(`^[a-zA-Z0-9._/-]+$`, name)

	// åŸºæœ¬é•¿åº¦æ£€æŸ¥
	if !matched || len(name) == 0 || len(name) > 256 {
		return false
	}

	// ä¸èƒ½ä»¥æ–œæ å¼€å¤´æˆ–ç»“å°¾
	if strings.HasPrefix(name, "/") || strings.HasSuffix(name, "/") {
		return false
	}

	// ä¸èƒ½æœ‰è¿ç»­çš„æ–œæ 
	if strings.Contains(name, "//") {
		return false
	}

	// éªŒè¯æ¯ä¸ªè·¯å¾„æ®µ
	segments := strings.Split(name, "/")
	for _, segment := range segments {
		// æ¯ä¸ªæ®µä¸èƒ½ä¸ºç©ºï¼Œä¸”åªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€è¿å­—ç¬¦ã€ä¸‹åˆ’çº¿å’Œç‚¹å·
		if len(segment) == 0 || len(segment) > 50 {
			return false
		}
		// æ·»åŠ äº†ç‚¹å· \.
		segmentMatched, _ := regexp.MatchString(`^[a-zA-Z0-9._-]+$`, segment)
		if !segmentMatched {
			return false
		}
		
		// å¯é€‰ï¼šé¢å¤–çš„ç‚¹å·è§„åˆ™
		// ä¸èƒ½ä»¥ç‚¹å·å¼€å¤´æˆ–ç»“å°¾
		if strings.HasPrefix(segment, ".") || strings.HasSuffix(segment, ".") {
			return false
		}
		
		// ä¸èƒ½æœ‰è¿ç»­çš„ç‚¹å·
		if strings.Contains(segment, "..") {
			return false
		}
	}

	return true
}

func GenerateDirectoryHTMLNew(repoPath string, entries []os.DirEntry) string {
	var html strings.Builder

	currentPath := "/" + repoPath

	html.WriteString(fmt.Sprintf(`<!DOCTYPE html>
<html>
<head>
    <title>Index of %s</title>
    <style>
        body { font-family: monospace; margin: 20px; }
        h1 { border-bottom: 1px solid #ccc; }
        .file-list { list-style: none; padding: 0; }
        .file-list li { padding: 5px 0; }
        .file-list a { text-decoration: none; color: #0066cc; }
        .file-list a:hover { text-decoration: underline; }
        .dir { font-weight: bold; }
        .size { color: #666; margin-left: 20px; }
        .parent { color: #999; }
        .file-info { display: flex; justify-content: space-between; align-items: center; }
        .file-name { flex: 1; }
        .file-meta { color: #666; font-size: 0.9em; }
    </style>
</head>
<body>
    <h1>ğŸ“ Repository: %s</h1>
    <ul class="file-list">`, currentPath, repoPath))

	// çˆ¶ç›®å½•é“¾æ¥
	var parentPath string
	parts := strings.Split(strings.Trim(repoPath, "/"), "/")
	if len(parts) > 1 {
		// è¿”å›ä¸Šä¸€çº§
		parentParts := parts[:len(parts)-1]
		parentPath = "/" + strings.Join(parentParts, "/")
	} else {
		// è¿”å›ä»“åº“åˆ—è¡¨
		parentPath = "/repo/"
	}

	html.WriteString(fmt.Sprintf(`        <li><a href="%s" class="parent">../</a></li>`, parentPath))

	// æ·»åŠ æ–‡ä»¶å’Œç›®å½•
	for _, entry := range entries {
		info, err := entry.Info()
		if err != nil {
			continue
		}

		name := entry.Name()

		if entry.IsDir() {
			linkPath := fmt.Sprintf("%s/%s", currentPath, name)
			html.WriteString(fmt.Sprintf(`        <li>
				<div class="file-info">
					<div class="file-name"><a href="%s" class="dir">ğŸ“ %s/</a></div>
					<div class="file-meta">Directory</div>
				</div>
			</li>`, linkPath, name))
		} else {
			linkPath := fmt.Sprintf("%s/%s", currentPath, name)
			size := FormatFileSize(info.Size())
			icon := GetFileIcon(name)
			modTime := info.ModTime().Format("2006-01-02 15:04:05")

			html.WriteString(fmt.Sprintf(`        <li>
				<div class="file-info">
					<div class="file-name"><a href="%s">%s %s</a></div>
					<div class="file-meta">%s | %s</div>
				</div>
			</li>`, linkPath, icon, name, size, modTime))
		}
	}

	html.WriteString(`    </ul>
    <hr>
    <p><em>Generated by Plus Artifacts Server</em></p>
</body>
</html>`)

	return html.String()
}

func GenerateDirectoryHTML(repoName, subPath string, entries []os.DirEntry) string {
	var html strings.Builder

	currentPath := fmt.Sprintf("/repo/%s/files", repoName)
	if subPath != "" {
		currentPath = fmt.Sprintf("/repo/%s/files/%s", repoName, subPath)
	}

	html.WriteString(fmt.Sprintf(`<!DOCTYPE html>
<html>
<head>
    <title>Index of %s</title>
    <style>
        body { font-family: monospace; margin: 20px; }
        h1 { border-bottom: 1px solid #ccc; }
        .file-list { list-style: none; padding: 0; }
        .file-list li { padding: 5px 0; }
        .file-list a { text-decoration: none; color: #0066cc; }
        .file-list a:hover { text-decoration: underline; }
        .dir { font-weight: bold; }
        .size { color: #666; margin-left: 20px; }
        .parent { color: #999; }
        .file-info { display: flex; justify-content: space-between; align-items: center; }
        .file-name { flex: 1; }
        .file-meta { color: #666; font-size: 0.9em; }
    </style>
</head>
<body>
    <h1>ğŸ“ Repository: %s/%s</h1>
    <ul class="file-list">`, currentPath, repoName, subPath))

	// ä¿®æ”¹çˆ¶ç›®å½•é“¾æ¥é€»è¾‘
	var parentPath string
	if subPath != "" {
		// å¦‚æœåœ¨å­ç›®å½•ä¸­ï¼Œè¿”å›ä¸Šä¸€çº§
		cleanSubPath := strings.Trim(subPath, "/")
		if !strings.Contains(cleanSubPath, "/") {
			// å•çº§å­ç›®å½•ï¼Œè¿”å›ä»“åº“æ ¹ç›®å½•
			parentPath = fmt.Sprintf("/repo/%s/files/", repoName)
		} else {
			// å¤šçº§å­ç›®å½•ï¼Œè¿”å›ä¸Šä¸€çº§
			parts := strings.Split(cleanSubPath, "/")
			parentSubPath := strings.Join(parts[:len(parts)-1], "/")
			parentPath = fmt.Sprintf("/repo/%s/files/%s/", repoName, parentSubPath)
		}
	} else {
		// å¦‚æœåœ¨ä»“åº“æ ¹ç›®å½•ï¼Œè¿”å›æ‰€æœ‰ä»“åº“åˆ—è¡¨
		parentPath = "/repo/"
	}

	html.WriteString(fmt.Sprintf(`        <li><a href="%s" class="parent">../</a></li>`, parentPath))

	// æ·»åŠ æ–‡ä»¶å’Œç›®å½•
	for _, entry := range entries {
		info, err := entry.Info()
		if err != nil {
			continue
		}

		name := entry.Name()

		if entry.IsDir() {
			linkPath := fmt.Sprintf("%s/%s/", currentPath, name)
			html.WriteString(fmt.Sprintf(`        <li>
				<div class="file-info">
					<div class="file-name"><a href="%s" class="dir">ğŸ“ %s/</a></div>
					<div class="file-meta">Directory</div>
				</div>
			</li>`, linkPath, name))
		} else {
			linkPath := fmt.Sprintf("%s/%s", currentPath, name)
			size := FormatFileSize(info.Size())
			icon := GetFileIcon(name)
			modTime := info.ModTime().Format("2006-01-02 15:04:05")

			html.WriteString(fmt.Sprintf(`        <li>
				<div class="file-info">
					<div class="file-name"><a href="%s">%s %s</a></div>
					<div class="file-meta">%s | %s</div>
				</div>
			</li>`, linkPath, icon, name, size, modTime))
		}
	}

	html.WriteString(`    </ul>
    <hr>
    <p><em>Generated by Plus Artifacts Server</em></p>
</body>
</html>`)

	return html.String()
}

func GenerateRepoListHTMLWithTypes(repos []string, getRepoType func(context.Context, string) (string, error)) string {
	var html strings.Builder

	html.WriteString(`<!DOCTYPE html>
<html>
<head>
    <title>Repository List</title>
    <style>
        body { font-family: monospace; margin: 20px; }
        h1 { border-bottom: 1px solid #ccc; color: #333; }
        .repo-list { list-style: none; padding: 0; }
        .repo-list li { padding: 10px 0; border-bottom: 1px solid #eee; }
        .repo-list a { text-decoration: none; color: #0066cc; font-size: 16px; }
        .repo-list a:hover { text-decoration: underline; }
        .repo-item { display: flex; justify-content: space-between; align-items: center; }
        .repo-name { font-weight: bold; }
        .repo-links { font-size: 14px; }
        .repo-links a { margin-left: 10px; color: #666; }
        .repo-links button { margin-left: 10px; padding: 2px 8px; font-size: 12px; }
        .back-link { margin-bottom: 20px; }
        .back-link a { color: #999; }
    </style>
</head>
<body>
    <div class="back-link">
        <a href="/">â† Back to Home</a>
    </div>
    <h1>ğŸ“ All Repositories</h1>
    <ul class="repo-list">`)
	
	if len(repos) == 0 {
		html.WriteString(`        <li>No repositories found.</li>`)
	} else {
		for _, repo := range repos {
			// è·å–ä»“åº“ç±»å‹
			repoType, err := getRepoType(context.Background(), repo)
			if err != nil {
				repoType = "unknown"
			}
			
			// æ ¹æ®ç±»å‹å†³å®šæ˜¯å¦æ˜¾ç¤º refresh æŒ‰é’®
			refreshButton := ""
			if repoType != "files" {
				refreshButton = fmt.Sprintf(`<button onclick="refreshRepo('%s')">Refresh</button>`, repo)
			}
			
			typeIcon := GetRepoTypeIcon(repoType)
			
			html.WriteString(fmt.Sprintf(`
        <li>
            <div class="repo-item">
                <div>
                    <a href="/%s" class="repo-name">%s %s (%s)</a>
                </div>
                <div class="repo-links">
                    <a href="/%s">Browse</a>
                    <a href="/repo/%s">Info</a>
                    %s
                </div>
            </div>
        </li>`, repo, typeIcon, repo, repoType, repo, repo, refreshButton))
		}
	}

	html.WriteString(`    </ul>
    <script>
       function refreshRepo(repoPath) {
    if (confirm('Refresh metadata for repository: ' + repoPath + '?')) {
        const button = event.target;
        const originalText = button.innerHTML;
        button.innerHTML = 'â³ Refreshing...';
        button.disabled = true;
        
        fetch('/repo/' + encodeURIComponent(repoPath) + '/refresh', {
            method: 'POST'
        })
        .then(response => response.json())
        .then(data => {
            // ğŸ”¥ ä¿®å¤ï¼šæ­£ç¡®è§£æåµŒå¥—çš„ JSON ç»“æ„
            const status = data.Status ? data.Status.status : data.status;
            const message = data.Status ? data.Status.message : data.message;
            
            if (status === 'success') {
                showAlert('Repository metadata refreshed successfully!', 'success');
                setTimeout(() => location.reload(), 1000);
            } else {
                showAlert('Refresh failed: ' + (message || 'Unknown error'), 'error');
            }
        })
        .catch(error => {
            showAlert('Refresh failed: ' + error.message, 'error');
        })
        .finally(() => {
            button.innerHTML = originalText;
            button.disabled = false;
        });
    }
}
 
    </script>
    <hr>
    <p><em>Generated by Plus Artifacts Server</em></p>
</body>
</html>`)

	return html.String()
}

func GenerateObjectStorageRepoHTML(repoName string, packages []types.PackageInfo) string {
	var html strings.Builder

	currentPath := "/" + repoName

	html.WriteString(fmt.Sprintf(`<!DOCTYPE html>
<html>
<head>
    <title>Repository: %s</title>
    <style>
        body { font-family: monospace; margin: 20px; }
        h1 { border-bottom: 1px solid #ccc; }
        .file-list { list-style: none; padding: 0; }
        .file-list li { padding: 5px 0; }
        .file-list a { text-decoration: none; color: #0066cc; }
        .file-list a:hover { text-decoration: underline; }
        .parent { color: #999; }
        .file-info { display: flex; justify-content: space-between; align-items: center; }
        .file-name { flex: 1; }
        .file-meta { color: #666; font-size: 0.9em; }
    </style>
</head>
<body>
    <h1>ğŸ“ Repository: %s</h1>
    <ul class="file-list">`, repoName, repoName))

	// çˆ¶ç›®å½•é“¾æ¥
	html.WriteString(`        <li><a href="/repo/" class="parent">../</a></li>`)

	// æ·»åŠ æ–‡ä»¶
	for _, pkg := range packages {
		linkPath := fmt.Sprintf("%s/%s", currentPath, pkg.Name)
		size := FormatFileSize(pkg.Size)
		icon := GetFileIcon(pkg.Name)

		html.WriteString(fmt.Sprintf(`        <li>
			<div class="file-info">
				<div class="file-name"><a href="%s">%s %s</a></div>
				<div class="file-meta">%s</div>
			</div>
		</li>`, linkPath, icon, pkg.Name, size))
	}

	html.WriteString(`    </ul>
    <hr>
    <p><em>Generated by Plus Artifacts Server</em></p>
</body>
</html>`)

	return html.String()
}

func DetectRepoTypeByPath(dirPath string) string {
    // 1. æ£€æŸ¥æ˜ç¡®çš„ä»“åº“æ ‡è¯†æ–‡ä»¶
    rpmIndicators := []string{
        "repodata/repomd.xml",
        "repodata",
    }
    
    debIndicators := []string{
        "Packages",
        "Packages.gz", 
        "Release",
        "InRelease",
    }
    
    for _, indicator := range rpmIndicators {
        if _, err := os.Stat(filepath.Join(dirPath, indicator)); err == nil {
            log.Logger.Debugf("âœ… RPM repository detected by indicator: %s", indicator)
            return "rpm"
        }
    }
    
    for _, indicator := range debIndicators {
        if _, err := os.Stat(filepath.Join(dirPath, indicator)); err == nil {
            log.Logger.Debugf("âœ… DEB repository detected by indicator: %s", indicator)
            return "deb"
        }
    }
    
    // 2. å¿«é€Ÿæ£€æŸ¥åŒ…æ–‡ä»¶ç±»å‹ï¼ˆé™åˆ¶æ£€æŸ¥æ•°é‡é¿å…æ€§èƒ½é—®é¢˜ï¼‰
    if entries, err := os.ReadDir(dirPath); err == nil {
        rpmCount := 0
        debCount := 0
        totalChecked := 0
        
        for _, entry := range entries {
            if entry.IsDir() {
                continue
            }
            
            name := strings.ToLower(entry.Name())
            if strings.HasSuffix(name, ".rpm") {
                rpmCount++
            } else if strings.HasSuffix(name, ".deb") {
                debCount++
            }
            
            totalChecked++
            if totalChecked >= 10 { // ğŸ”¥ é™åˆ¶æ£€æŸ¥æ•°é‡ï¼Œé¿å…å¤§ç›®å½•éå†
                break
            }
        }
        
        if rpmCount > 0 && rpmCount >= debCount {
            log.Logger.Debugf("âœ… RPM repository detected by file content (%d rpm files)", rpmCount)
            return "rpm"
        } else if debCount > 0 && debCount > rpmCount {
            log.Logger.Debugf("âœ… DEB repository detected by file content (%d deb files)", debCount)
            return "deb"
        } else if totalChecked > 0 {
            log.Logger.Debugf("âœ… Files repository detected (%d files checked)", totalChecked)
            return "files"
        }
    }
    
    return "unknown"
}

func GenerateEnhancedDirectoryHTML(cleanPath, fullPath, repoType string) (string, error) {
    entries, err := os.ReadDir(fullPath)
    if err != nil {
		msg := fmt.Errorf("âŒ Cannot read directory %s: %v", fullPath, err)
        log.Logger.Debug(msg)
        return "", msg
    }

    var html strings.Builder
    
    typeIcon := GetRepoTypeIcon(repoType)
    
    // 1. HTML å¤´éƒ¨å’Œæ ·å¼
    html.WriteString(`<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">`)
    
    html.WriteString(fmt.Sprintf(`    <title>Repository: %s</title>`, cleanPath))
    
    html.WriteString(`
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            margin: 0; 
            padding: 20px; 
            background-color: #f8f9fa; 
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            border-radius: 8px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
            overflow: hidden; 
        }
        .header { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            color: white; 
            padding: 20px; 
        }
        .header h1 { 
            margin: 0 0 10px 0; 
            font-size: 24px; 
            font-weight: 600; 
        }
        .repo-info { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-top: 15px; 
        }
        .repo-meta { 
            opacity: 0.9; 
            font-size: 14px; 
        }
        .repo-actions { 
            display: flex; 
            gap: 10px; 
        }
        .btn { 
            padding: 8px 16px; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer; 
            font-size: 14px; 
            font-weight: 500; 
            text-decoration: none; 
            display: inline-flex; 
            align-items: center; 
            gap: 6px; 
            transition: all 0.2s; 
        }
        .btn-primary { 
            background: rgba(255,255,255,0.2); 
            color: white; 
            border: 1px solid rgba(255,255,255,0.3); 
        }
        .btn-primary:hover { 
            background: rgba(255,255,255,0.3); 
        }
        .btn-secondary { 
            background: #6c757d; 
            color: white; 
        }
        .btn-secondary:hover { 
            background: #5a6268; 
        }
        .content { 
            padding: 20px; 
        }
        .breadcrumb { 
            background: #f8f9fa; 
            padding: 12px 20px; 
            border-bottom: 1px solid #dee2e6; 
            font-size: 14px; 
        }
        .breadcrumb a { 
            color: #007bff; 
            text-decoration: none; 
        }
        .breadcrumb a:hover { 
            text-decoration: underline; 
        }
        .file-list { 
            list-style: none; 
            padding: 0; 
            margin: 0; 
        }
        .file-item { 
            display: flex; 
            align-items: center; 
            padding: 12px 0; 
            border-bottom: 1px solid #f1f3f4; 
            transition: background-color 0.2s; 
        }
        .file-item:hover { 
            background-color: #f8f9fa; 
        }
        .file-icon { 
            font-size: 20px; 
            margin-right: 12px; 
            width: 24px; 
            text-align: center; 
        }
        .file-info { 
            flex: 1; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
        }
        .file-name { 
            font-weight: 500; 
        }
        .file-name a { 
            color: #333; 
            text-decoration: none; 
        }
        .file-name a:hover { 
            color: #007bff; 
            text-decoration: underline; 
        }
        .file-meta { 
            color: #6c757d; 
            font-size: 13px; 
            text-align: right; 
            min-width: 200px; 
        }
        .parent-link { 
            color: #6c757d !important; 
            font-style: italic; 
        }
        .stats { 
            background: #f8f9fa; 
            padding: 15px 20px; 
            border-top: 1px solid #dee2e6; 
            font-size: 14px; 
            color: #6c757d; 
        }
        .alert { 
            padding: 12px 16px; 
            margin: 10px 0; 
            border-radius: 6px; 
            font-size: 14px; 
        }
        .alert-success { 
            background: #d4edda; 
            color: #155724; 
            border: 1px solid #c3e6cb; 
        }
        .alert-error { 
            background: #f8d7da; 
            color: #721c24; 
            border: 1px solid #f5c6cb; 
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">`)
    
    // 2. å¤´éƒ¨ä¿¡æ¯
    html.WriteString(fmt.Sprintf(`            <h1>%s %s</h1>`, typeIcon, cleanPath))
    
    html.WriteString(`            <div class="repo-info">
                <div class="repo-meta">`)
    
    html.WriteString(fmt.Sprintf(`                    <div>Type: <strong>%s</strong></div>`, repoType))
    html.WriteString(fmt.Sprintf(`                    <div>Path: <code>%s</code></div>`, cleanPath))
    
    html.WriteString(`                </div>
                <div class="repo-actions">`)

    // 3. æ ¹æ®ä»“åº“ç±»å‹æ·»åŠ æ“ä½œæŒ‰é’®
    switch repoType {
    case "rpm", "deb":
        html.WriteString(fmt.Sprintf(`
                    <button class="btn btn-primary" onclick="refreshRepo('%s')">
                        ğŸ”„ Refresh Metadata
                    </button>
                    <a href="/repo/%s" class="btn btn-primary" target="_blank">
                        â„¹ï¸ Repository Info
                    </a>`, cleanPath, cleanPath))
    case "files":
        html.WriteString(fmt.Sprintf(`
                    <a href="/repo/%s" class="btn btn-primary" target="_blank">
                        â„¹ï¸ Repository Info
                    </a>
                    <button class="btn btn-secondary" onclick="showUploadDialog('%s')">
                        ğŸ“¤ Upload File
                    </button>`, cleanPath, cleanPath))
    case "unknown":
        html.WriteString(`
                    <span style="color: rgba(255,255,255,0.7);">ğŸ¤” Repository type unknown</span>`)
    }
    
    html.WriteString(`
                </div>
            </div>
        </div>`)

    // é¢åŒ…å±‘å¯¼èˆª
    html.WriteString(`
        <div class="breadcrumb">`)
    
    // æ„å»ºé¢åŒ…å±‘
    parts := strings.Split(strings.Trim(cleanPath, "/"), "/")
    html.WriteString(`<a href="/repo/">ğŸ“ All Repositories</a>`)
    
    currentBreadcrumbPath := ""
    for i, part := range parts {
        if part == "" {
            continue
        }
        
        if currentBreadcrumbPath == "" {
            currentBreadcrumbPath = part
        } else {
            currentBreadcrumbPath += "/" + part
        }
        
        if i == len(parts)-1 {
            // å½“å‰ç›®å½•ï¼Œä¸åŠ é“¾æ¥
            html.WriteString(fmt.Sprintf(` / <strong>%s</strong>`, part))
        } else {
            // çˆ¶ç›®å½•ï¼Œæ·»åŠ é“¾æ¥
            html.WriteString(fmt.Sprintf(` / <a href="/%s">%s</a>`, currentBreadcrumbPath, part))
        }
    }
    
    html.WriteString(`
        </div>`)

    // å†…å®¹åŒºåŸŸ
    html.WriteString(`
        <div class="content">
            <div id="alerts"></div>
            <ul class="file-list">`)

    // çˆ¶ç›®å½•é“¾æ¥
    var parentPath string
    if len(parts) > 1 {
        parentParts := parts[:len(parts)-1]
        parentPath = "/" + strings.Join(parentParts, "/")
    } else {
        parentPath = "/repo/"
    }
    
    html.WriteString(fmt.Sprintf(`
                <li class="file-item">
                    <div class="file-icon">ğŸ“</div>
                    <div class="file-info">
                        <div class="file-name">
                            <a href="%s" class="parent-link">../</a>
                        </div>
                        <div class="file-meta">Parent Directory</div>
                    </div>
                </li>`, parentPath))

    // ç»Ÿè®¡ä¿¡æ¯
    var totalSize int64
    dirCount := 0
    fileCount := 0
    rpmCount := 0
    debCount := 0

	currentPath := "/" + cleanPath

    // æ–‡ä»¶å’Œç›®å½•åˆ—è¡¨
    for _, entry := range entries {
        info, err := entry.Info()
        if err != nil {
            continue
        }

        name := entry.Name()
        
        if entry.IsDir() {
            dirCount++
            linkPath := fmt.Sprintf("%s/%s", currentPath, name)
            html.WriteString(fmt.Sprintf(`
                <li class="file-item">
                    <div class="file-icon">ğŸ“</div>
                    <div class="file-info">
                        <div class="file-name">
                            <a href="%s">%s/</a>
                        </div>
                        <div class="file-meta">Directory</div>
                    </div>
                </li>`, linkPath, name))
        } else {
            fileCount++
            totalSize += info.Size()
            
            linkPath := fmt.Sprintf("%s/%s", currentPath, name)
            size := FormatFileSize(info.Size())
            icon := GetFileIcon(name)
            modTime := info.ModTime().Format("2006-01-02 15:04")
            
            // ç»Ÿè®¡åŒ…æ–‡ä»¶
            nameLower := strings.ToLower(name)
            if strings.HasSuffix(nameLower, ".rpm") {
                rpmCount++
            } else if strings.HasSuffix(nameLower, ".deb") {
                debCount++
            }

            html.WriteString(fmt.Sprintf(`
                <li class="file-item">
                    <div class="file-icon">%s</div>
                    <div class="file-info">
                        <div class="file-name">
                            <a href="%s">%s</a>
                        </div>
                        <div class="file-meta">
                            %s<br>
                            <small>%s</small>
                        </div>
                    </div>
                </li>`, icon, linkPath, name, size, modTime))
        }
    }

    html.WriteString(`
            </ul>
        </div>`)

    // ç»Ÿè®¡ä¿¡æ¯æ 
    html.WriteString(fmt.Sprintf(`
        <div class="stats">
            <strong>Statistics:</strong> 
            %d directories, %d files`, dirCount, fileCount))
    
    if rpmCount > 0 || debCount > 0 {
        html.WriteString(fmt.Sprintf(` (%d RPM, %d DEB packages)`, rpmCount, debCount))
    }
    
    html.WriteString(fmt.Sprintf(`, Total size: %s
        </div>`, FormatFileSize(totalSize)))

// ä¿®å¤ showUploadDialog å‡½æ•°
html.WriteString(`
    <script>
        function showAlert(message, type = 'success') {
            const alertsDiv = document.getElementById('alerts');
            const alertDiv = document.createElement('div');
            alertDiv.className = 'alert alert-' + type;
            alertDiv.textContent = message;
            alertsDiv.appendChild(alertDiv);
            
            setTimeout(() => {
                alertDiv.remove();
            }, 5000);
        }
        
function refreshRepo(repoPath) {
    if (confirm('Refresh metadata for repository: ' + repoPath + '?')) {
        const button = event.target;
        const originalText = button.innerHTML;
        button.innerHTML = 'â³ Refreshing...';
        button.disabled = true;
        
        fetch('/repo/' + encodeURIComponent(repoPath) + '/refresh', {
            method: 'POST'
        })
        .then(response => response.json())
        .then(data => {
            // ğŸ”¥ ä¿®å¤ï¼šæ­£ç¡®è§£æåµŒå¥—çš„ JSON ç»“æ„
            const status = data.Status ? data.Status.status : data.status;
            const message = data.Status ? data.Status.message : data.message;
            
            if (status === 'success') {
                showAlert('Repository metadata refreshed successfully!', 'success');
                setTimeout(() => location.reload(), 1000);
            } else {
                showAlert('Refresh failed: ' + (message || 'Unknown error'), 'error');
            }
        })
        .catch(error => {
            showAlert('Refresh failed: ' + error.message, 'error');
        })
        .finally(() => {
            button.innerHTML = originalText;
            button.disabled = false;
        });
    }
}
        
        function showUploadDialog(repoPath) {
            // ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨å­—ç¬¦ä¸²æ‹¼æ¥è€Œä¸æ˜¯æ¨¡æ¿å­—ç¬¦ä¸²
            const uploadHtml = '<div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; align-items: center; justify-content: center;">' +
                '<div style="background: white; padding: 20px; border-radius: 8px; max-width: 400px; width: 90%;">' +
                    '<h3>Upload File to Repository</h3>' +
                    '<form id="uploadForm" enctype="multipart/form-data">' +
                        '<div style="margin: 15px 0;">' +
                            '<label>Select file:</label><br>' +
                            '<input type="file" name="file" required style="width: 100%; margin-top: 5px;">' +
                        '</div>' +
                        '<div style="text-align: right; margin-top: 20px;">' +
                            '<button type="button" onclick="closeUploadDialog()" style="margin-right: 10px;">Cancel</button>' +
                            '<button type="submit">Upload</button>' +
                        '</div>' +
                    '</form>' +
                '</div>' +
            '</div>';
            
            document.body.insertAdjacentHTML('beforeend', uploadHtml);
            
            document.getElementById('uploadForm').onsubmit = function(e) {
                e.preventDefault();
                uploadFile(repoPath, this);
            };
        }
        
        function closeUploadDialog() {
            const dialog = document.querySelector('[style*="position: fixed"]');
            if (dialog) dialog.remove();
        }
        
        function uploadFile(repoPath, form) {
            const formData = new FormData(form);
            const submitBtn = form.querySelector('button[type="submit"]');
            
            submitBtn.textContent = 'Uploading...';
            submitBtn.disabled = true;
            
            fetch('/repo/' + encodeURIComponent(repoPath) + '/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showAlert('File uploaded successfully!', 'success');
                    closeUploadDialog();
                    setTimeout(() => location.reload(), 1000);
                } else {
                    showAlert('Upload failed: ' + (data.message || 'Unknown error'), 'error');
                }
            })
            .catch(error => {
                showAlert('Upload failed: ' + error.message, 'error');
            })
            .finally(() => {
                submitBtn.textContent = 'Upload';
                submitBtn.disabled = false;
            });
        }
        
        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeUploadDialog();
            }
        });
    </script>`)
	return html.String(), nil
}

func GenerateObjectStorageDirectoryHTML(repoName, displayPath string, packages []types.PackageInfo) string {
    var html strings.Builder
    
    // å¤ç”¨ç°æœ‰æ ·å¼ï¼Œä½†æ ‡è¯†ä¸º Files Repository
    html.WriteString(`<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">`)
    
    html.WriteString(fmt.Sprintf(`    <title>Files Repository: %s</title>`, displayPath))
    
    // ä½¿ç”¨ä¸ generateEnhancedDirectoryHTML ç›¸åŒçš„æ ·å¼
    html.WriteString(`
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            margin: 0; 
            padding: 20px; 
            background-color: #f8f9fa; 
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            border-radius: 8px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
            overflow: hidden; 
        }
        .header { 
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%); 
            color: white; 
            padding: 20px; 
        }
        .header h1 { 
            margin: 0 0 10px 0; 
            font-size: 24px; 
            font-weight: 600; 
        }
        .repo-info { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-top: 15px; 
        }
        .repo-meta { 
            opacity: 0.9; 
            font-size: 14px; 
        }
        .content { 
            padding: 20px; 
        }
        .file-list { 
            list-style: none; 
            padding: 0; 
            margin: 0; 
        }
        .file-item { 
            display: flex; 
            align-items: center; 
            padding: 12px 0; 
            border-bottom: 1px solid #f1f3f4; 
            transition: background-color 0.2s; 
        }
        .file-item:hover { 
            background-color: #f8f9fa; 
        }
        .file-icon { 
            font-size: 20px; 
            margin-right: 12px; 
            width: 24px; 
            text-align: center; 
        }
        .file-info { 
            flex: 1; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
        }
        .file-name { 
            font-weight: 500; 
        }
        .file-name a { 
            color: #333; 
            text-decoration: none; 
        }
        .file-name a:hover { 
            color: #007bff; 
            text-decoration: underline; 
        }
        .file-meta { 
            color: #6c757d; 
            font-size: 13px; 
            text-align: right; 
            min-width: 200px; 
        }
        .parent-link { 
            color: #6c757d !important; 
            font-style: italic; 
        }
        .stats { 
            background: #f8f9fa; 
            padding: 15px 20px; 
            border-top: 1px solid #dee2e6; 
            font-size: 14px; 
            color: #6c757d; 
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">`)
    
    html.WriteString(fmt.Sprintf(`            <h1>ğŸ“ %s</h1>`, displayPath))
    
    html.WriteString(`            <div class="repo-info">
                <div class="repo-meta">`)
    
    html.WriteString(`                    <div>Type: <strong>Files Repository (Object Storage)</strong></div>`)
    html.WriteString(fmt.Sprintf(`                    <div>Repository: <code>%s</code></div>`, repoName))
    html.WriteString(fmt.Sprintf(`                    <div>Files: <strong>%d</strong></div>`, len(packages)))
    
    html.WriteString(`                </div>
            </div>
        </div>`)

    // å†…å®¹åŒºåŸŸ
    html.WriteString(`
        <div class="content">
            <ul class="file-list">`)

    // çˆ¶ç›®å½•é“¾æ¥
    html.WriteString(`
                <li class="file-item">
                    <div class="file-icon">ğŸ“</div>
                    <div class="file-info">
                        <div class="file-name">
                            <a href="/repo/" class="parent-link">../</a>
                        </div>
                        <div class="file-meta">Back to repositories</div>
                    </div>
                </li>`)

    // ç»Ÿè®¡ä¿¡æ¯
    var totalSize int64

    // æ–‡ä»¶åˆ—è¡¨
    for _, pkg := range packages {
        totalSize += pkg.Size
        icon := GetFileIcon(pkg.Name)
        size := FormatFileSize(pkg.Size)
        linkPath := fmt.Sprintf("/%s/%s", displayPath, pkg.Name)

        html.WriteString(fmt.Sprintf(`
                <li class="file-item">
                    <div class="file-icon">%s</div>
                    <div class="file-info">
                        <div class="file-name">
                            <a href="%s">%s</a>
                        </div>
                        <div class="file-meta">%s</div>
                    </div>
                </li>`, icon, linkPath, pkg.Name, size))
    }

    html.WriteString(`
            </ul>
        </div>`)

    // ç»Ÿè®¡ä¿¡æ¯æ 
    html.WriteString(fmt.Sprintf(`
        <div class="stats">
            <strong>Statistics:</strong> 
            %d files, Total size: %s
        </div>`, len(packages), FormatFileSize(totalSize)))

    html.WriteString(`
    </div>
</body>
</html>`)

	return html.String()
}

func HandleRootPath() string {
	html := `<!DOCTYPE html>
<html>
<head>
    <title>Plus Artifacts Server</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 50px; text-align: center; }
        .option { margin: 20px; padding: 20px; border: 1px solid #ddd; border-radius: 5px; display: inline-block; }
        .option a { text-decoration: none; color: #0066cc; font-size: 18px; }
        .option:hover { background-color: #f5f5f5; }
    </style>
</head>
<body>
    <h1>Plus Artifacts Server</h1>
    <p>Choose your preferred interface:</p>
    
    <div class="option">
        <a href="/static/">ğŸ“± Modern Web UI</a>
        <p>Feature-rich web interface for package management</p>
    </div>
    
    <div class="option">
        <a href="/repo/">ğŸ“ Browse Repositories</a>
        <p>Traditional file browser (nginx-style)</p>
    </div>
    
    <div class="option">
        <a href="/repos">ğŸ”§ API Endpoints</a>
        <p>JSON API for programmatic access</p>
    </div>
</body>
</html>`

	return html
}

func GetContentTypeByExtension(filename string) string {
    ext := strings.ToLower(filepath.Ext(filename))
    switch ext {
    case ".txt", ".log":
        return "text/plain; charset=utf-8"
    case ".json":
        return "application/json"
    case ".xml":
        return "application/xml"
    case ".html", ".htm":
        return "text/html; charset=utf-8"
    case ".css":
        return "text/css"
    case ".js":
        return "application/javascript"
    case ".png":
        return "image/png"
    case ".jpg", ".jpeg":
        return "image/jpeg"
    case ".gif":
        return "image/gif"
    case ".svg":
        return "image/svg+xml"
    case ".pdf":
        return "application/pdf"
    case ".zip":
        return "application/zip"
    case ".gz":
        return "application/gzip"
    case ".rpm":
        return "application/x-rpm"
    case ".deb":
        return "application/vnd.debian.binary-package"
    case ".sql":
        return "text/plain; charset=utf-8"
    default:
        return "application/octet-stream"
    }
}

func GetRepoTypeIcon(repoType string) string {
    switch repoType {
    case "rpm":
        return "ğŸ“¦" // RPM åŒ…
    case "deb":
        return "ğŸ“‹" // DEB åŒ…
    case "files":
        return "ğŸ“" // æ–‡ä»¶
    default:
        return "â“" // æœªçŸ¥ç±»å‹
    }
}

func FormatFileSize(size int64) string {
	const unit = 1024
	if size < unit {
		return fmt.Sprintf("%d B", size)
	}
	div, exp := int64(unit), 0
	for n := size / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(size)/float64(div), "KMGTPE"[exp])
}

func GetFileIcon(filename string) string {
	ext := strings.ToLower(filepath.Ext(filename))
	switch ext {
	case ".rpm":
		return "ğŸ“¦"
	case ".deb":
		return "ğŸ“¦"
	case ".xml":
		return "ğŸ“„"
	case ".gz", ".xz":
		return "ğŸ—œï¸"
	case ".txt":
		return "ğŸ“"
	case ".json":
		return "ğŸ”§"
	case ".log":
		return "ğŸ“‹"
	default:
		return "ğŸ“„"
	}
}

func GetStaticContentType(filename string) string {
	ext := strings.ToLower(filepath.Ext(filename))
	switch ext {
	case ".html":
		return "text/html; charset=utf-8"
	case ".css":
		return "text/css"
	case ".js":
		return "application/javascript"
	case ".json":
		return "application/json"
	case ".png":
		return "image/png"
	case ".jpg", ".jpeg":
		return "image/jpeg"
	case ".gif":
		return "image/gif"
	case ".svg":
		return "image/svg+xml"
	case ".ico":
		return "image/x-icon"
	default:
		return "application/octet-stream"
	}
}

func GetContentType(filename string) string {
	switch {
	case strings.HasSuffix(filename, ".xml"):
		return "application/xml"
	case strings.HasSuffix(filename, ".xml.gz"):
		return "application/gzip"
	case strings.HasSuffix(filename, ".sqlite"):
		return "application/x-sqlite3"
	default:
		return "application/octet-stream"
	}
}

func IsObjectStorage(repoType string) bool {
	switch repoType {
	case "files":
		return true  // files ç±»å‹ä½¿ç”¨å¯¹è±¡å­˜å‚¨
	case "rpm", "deb":
		return false // rpm å’Œ deb ç±»å‹ä½¿ç”¨æœ¬åœ°å­˜å‚¨
	default:
		return false // é»˜è®¤æœ¬åœ°å­˜å‚¨
	}
}

func GetFileTypeErrorMessage(repoType string) string {
	switch repoType {
	case "rpm":
		return "This RPM repository only accepts .rpm files"
	case "deb":
		return "This DEB repository only accepts .deb files"
	case "files":
		return "Invalid file type"
	default:
		return "Invalid file type for this repository"
	}
}

func ValidateFileTypeForRepo(filename, repoType string) bool {
	filename = strings.ToLower(filename)
	
	switch repoType {
	case "rpm":
		return strings.HasSuffix(filename, ".rpm")
	case "deb":
		return strings.HasSuffix(filename, ".deb")
	case "files":
		return true // files ç±»å‹æ¥å—ä»»ä½•æ–‡ä»¶
	default:
		return false
	}
}

// å¸¸è§æ–‡ä»¶æ‰©å±•ååˆ—è¡¨
var commonFileExtensions = map[string]bool{
    ".txt": true, ".log": true, ".json": true, ".xml": true,
    ".html": true, ".htm": true, ".css": true, ".js": true,
    ".png": true, ".jpg": true, ".jpeg": true, ".gif": true,
    ".pdf": true, ".zip": true, ".gz": true, ".tar": true,
    ".rpm": true, ".deb": true, ".exe": true, ".msi": true,
    ".doc": true, ".docx": true, ".xls": true, ".xlsx": true,
    ".mp3": true, ".mp4": true, ".avi": true, ".mov": true,
    ".sql": true, ".db": true, ".sqlite": true,
    ".conf": true, ".cfg": true, ".ini": true, ".yaml": true, ".yml": true,
}

func AnalyzeObjectStoragePath(path string) (isFile bool, isDirectory bool) {
    // æ¸…ç†è·¯å¾„
    cleanPath := strings.Trim(path, "/")
    if cleanPath == "" {
        return false, true // æ ¹è·¯å¾„æ˜¯ç›®å½•
    }
    
    // æ˜ç¡®çš„ç›®å½•æ ‡è¯†
    if strings.HasSuffix(path, "/") {
        return false, true
    }
    
    // è·å–è·¯å¾„çš„æœ€åéƒ¨åˆ†
    segments := strings.Split(cleanPath, "/")
    lastSegment := segments[len(segments)-1]
    
    // æ£€æŸ¥æ˜¯å¦åŒ…å«æ–‡ä»¶æ‰©å±•å
    if strings.Contains(lastSegment, ".") {
        ext := strings.ToLower(filepath.Ext(lastSegment))
        
        // å·²çŸ¥æ–‡ä»¶æ‰©å±•å
        if commonFileExtensions[ext] {
            return true, false
        }
        
        // çœ‹èµ·æ¥åƒæ–‡ä»¶åçš„æ¨¡å¼
        if matched, _ := regexp.MatchString(`\.[a-zA-Z0-9]{1,10}$`, ext); matched {
            return true, false
        }
    }
    
    // ç‰¹æ®Šç›®å½•åæ¨¡å¼
    directoryPatterns := []string{
        "repodata", "dists", "pool", "binary-", "source", "Release", "Packages",
    }
    
    for _, pattern := range directoryPatterns {
        if strings.Contains(lastSegment, pattern) {
            return false, true
        }
    }
    
    // é»˜è®¤è®¤ä¸ºæ˜¯ç›®å½•
    return false, true
}